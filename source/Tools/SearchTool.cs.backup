// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

using Microsoft.Azure.Functions.Worker;
using Microsoft.Azure.Functions.Worker.Extensions.Mcp;
using Microsoft.Extensions.Logging;
using Azure.Maps.Search;
using Azure.Maps.Search.Models;
using Azure.Maps.Mcp.Services;
using Azure.Maps.Mcp.Common;
using Azure.Core.GeoJson;
using System.Text.Json;
using CountryData.Standard;

namespace Azure.Maps.Mcp.Tools;

/// <summary>
/// Azure Maps Search Tool providing geocoding, reverse geocoding, and administrative boundary polygon capabilities
/// </summary>
public class SearchTool(IAzureMapsService azureMapsService, ILogger<SearchTool> logger)
{
    private readonly MapsSearchClient _searchClient = azureMapsService.SearchClient;
    private readonly CountryHelper _countryHelper = new();

    /// <summary>
    /// Converts an address or place name to geographic coordinates
    /// </summary>
    [Function(nameof(Geocoding))]
    public async Task<string> Geocoding(
        [McpToolTrigger(
            "search_geocoding",
            "Convert street addresses, landmarks, or place names into precise geographic coordinates (latitude and longitude). This advanced forward geocoding service handles various address formats from complete street addresses to partial addresses or landmark names. Returns detailed address components, confidence scores, and quality metrics. Essential for mapping applications, location-based services, and spatial analysis."
        )] ToolInvocationContext context,
        [McpToolProperty(
            "address",
            "string",
            "Address, partial address, or landmark name to geocode. Supports various formats including full addresses, landmarks, points of interest, and partial addresses. Examples: '1600 Pennsylvania Avenue, Washington, DC', 'Eiffel Tower', 'Times Square', '123 Main Street, Seattle, WA', 'Central Park'"
        )] string address,
        [McpToolProperty(
            "maxResults",
            "number",
            "Maximum number of results to return as a number. Must be between 1 and 20. Higher values provide more alternatives but may include less relevant results. Examples: 1, 5, 10, 20. Default is 5 if not specified."
        )] int maxResults = 5
    )
    {
        try
        {
            // Validate input parameters
            var validationError = ValidateGeocodingInput(address, ref maxResults);
            if (validationError != null)
            {
                return JsonSerializer.Serialize(new { error = validationError });
            }

            var normalizedAddress = address.Trim();
            logger.LogInformation("Geocoding address: '{Address}' (requesting {MaxResults} results)", normalizedAddress, maxResults);

            var options = new GeocodingQuery() { Query = normalizedAddress, Top = maxResults };
            var response = await _searchClient.GetGeocodingAsync(query: normalizedAddress, options: options);

            if (response.Value?.Features != null && response.Value.Features.Any())
            {
                var results = response.Value.Features.Select((feature, index) => new
                {
                    ResultIndex = index + 1,
                    Address = feature.Properties.Address?.FormattedAddress,
                    Coordinates = new
                    {
                        Longitude = feature.Geometry.Coordinates[0],
                        Latitude = feature.Geometry.Coordinates[1]
                    },
                    AddressComponents = new
                    {
                        StreetNumber = feature.Properties.Address?.StreetNumber,
                        StreetName = feature.Properties.Address?.StreetName,
                        Neighborhood = feature.Properties.Address?.Neighborhood,
                        Locality = feature.Properties.Address?.Locality,
                        PostalCode = feature.Properties.Address?.PostalCode,
                        CountryRegion = feature.Properties.Address?.CountryRegion
                    },
                    QualityMetrics = new
                    {
                        Confidence = feature.Properties.Confidence.ToString(),
                        MatchCodes = feature.Properties.MatchCodes?.Select(mc => mc.ToString()).ToArray(),
                        ResultRank = index + 1,
                        AddressCompleteness = CalculateAddressCompleteness(feature.Properties.Address)
                    },
                    LocationType = DetermineLocationType(feature.Properties.Address, feature.Properties.MatchCodes)
                }).ToList();

                var result = new
                {
                    Query = new
                    {
                        OriginalAddress = normalizedAddress,
                        MaxResults = maxResults,
                        ProcessedAt = DateTime.UtcNow
                    },
                    Summary = new
                    {
                        TotalResults = results.Count,
                        HasMultipleResults = results.Count > 1,
                        ResultsLimited = results.Count == maxResults,
                        RecommendedResult = results.FirstOrDefault()
                    },
                    Results = results,
                    SearchInsights = new
                    {
                        QueryType = DetermineGeocodingQueryType(normalizedAddress),
                        QualityAssessment = results.Any() ? AssessOverallQuality(results.First()) : "No Results"
                    }
                };

                logger.LogInformation("Successfully geocoded address '{Address}': found {Count} results with confidence levels", 
                    normalizedAddress, results.Count);

                return JsonSerializer.Serialize(new { success = true, result }, new JsonSerializerOptions { WriteIndented = false });
            }

            logger.LogWarning("No geocoding results found for address: '{Address}'", normalizedAddress);
            return JsonSerializer.Serialize(new { 
                success = false, 
                message = "No results found",
                searchHints = GenerateGeocodingSearchHints(normalizedAddress)
            });
        }
        catch (RequestFailedException ex)
        {
            logger.LogError(ex, "Azure Maps API error during geocoding of '{Address}': {Message}", address, ex.Message);
            return JsonSerializer.Serialize(new { error = $"API Error: {ex.Message}" });
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "Unexpected error during geocoding of '{Address}'", address);
            return JsonSerializer.Serialize(new { error = "An unexpected error occurred" });
        }
    }

    /// <summary>
    /// Validate geocoding input parameters
    /// </summary>
    private static string? ValidateGeocodingInput(string? address, ref int maxResults)
    {
        if (string.IsNullOrWhiteSpace(address))
        {
            return "Address is required";
        }

        var trimmedAddress = address.Trim();
        if (trimmedAddress.Length < 2)
        {
            return "Address must be at least 2 characters long";
        }

        if (trimmedAddress.Length > 2048)
        {
            return "Address is too long (maximum 2048 characters)";
        }

        // Normalize maxResults to valid range
        maxResults = Math.Max(1, Math.Min(20, maxResults));
        return null;
    }

    /// <summary>
    /// Calculate address completeness percentage
    /// </summary>
    private static int CalculateAddressCompleteness(Azure.Maps.Search.Models.Address? address)
    {
        if (address == null) return 0;

        var components = new string?[]
        {
            address.StreetNumber,
            address.StreetName,
            address.Locality,
            address.PostalCode,
            address.CountryRegion?.ToString()
        };

        var presentComponents = components.Count(c => !string.IsNullOrWhiteSpace(c));
        return (presentComponents * 100) / components.Length;
    }

    /// <summary>
    /// Determine the type of location from geocoding result
    /// </summary>
    private static string DetermineLocationType(Azure.Maps.Search.Models.Address? address, 
        IReadOnlyList<Azure.Maps.Search.Models.MatchCodesEnum>? matchCodes)
    {
        if (!string.IsNullOrWhiteSpace(address?.StreetNumber) && !string.IsNullOrWhiteSpace(address?.StreetName))
            return "Street Address";
        
        if (!string.IsNullOrWhiteSpace(address?.StreetName))
            return "Street";
        
        if (matchCodes?.Any(mc => mc.ToString().Contains("POI")) == true)
            return "Point of Interest";
        
        if (!string.IsNullOrWhiteSpace(address?.Locality))
            return "City/Locality";
        
        if (!string.IsNullOrWhiteSpace(address?.PostalCode))
            return "Postal Code Area";
        
        return "Geographic Location";
    }

    /// <summary>
    /// Determine the type of geocoding query for insights
    /// </summary>
    private static string DetermineGeocodingQueryType(string query)
    {
        var lowerQuery = query.ToLowerInvariant();
        
        if (System.Text.RegularExpressions.Regex.IsMatch(query, @"^\d+\s+[\w\s]+"))
            return "Street Address";
        
        if (lowerQuery.Contains("street") || lowerQuery.Contains("avenue") || lowerQuery.Contains("road") || 
            lowerQuery.Contains("boulevard") || lowerQuery.Contains("drive"))
            return "Street-based";
        
        if (System.Text.RegularExpressions.Regex.IsMatch(query, @"\d{5}"))
            return "Postal Code Included";
        
        if (lowerQuery.Contains("tower") || lowerQuery.Contains("building") || lowerQuery.Contains("center") ||
            lowerQuery.Contains("mall") || lowerQuery.Contains("park"))
            return "Landmark/POI";
        
        return "General Location";
    }

    /// <summary>
    /// Assess overall quality of the geocoding result
    /// </summary>
    private static string AssessOverallQuality(dynamic result)
    {
        var confidence = result.QualityMetrics.Confidence.ToString();
        var completeness = (int)result.QualityMetrics.AddressCompleteness;
        
        if (confidence == "High" && completeness >= 80)
            return "Excellent";
        
        if (confidence == "High" || completeness >= 60)
            return "Good";
        
        if (confidence == "Medium" || completeness >= 40)
            return "Fair";
        
        return "Limited";
    }

    /// <summary>
    /// Generate helpful hints for failed geocoding searches
    /// </summary>
    private static object GenerateGeocodingSearchHints(string address)
    {
        var hints = new List<string>();
        
        if (address.Length < 5)
        {
            hints.Add("Try providing a more complete address");
        }
        
        if (!address.Any(char.IsDigit))
        {
            hints.Add("Include street numbers or postal codes for better accuracy");
        }
        
        if (!address.Contains(","))
        {
            hints.Add("Try adding city, state, or country information separated by commas");
        }
        
        hints.Add("Verify spelling of street names and city names");
        hints.Add("Try searching for nearby landmarks or points of interest");
        
        return new
        {
            NoResultsFound = true,
            Suggestions = hints,
            ExampleFormats = new[]
            {
                "123 Main Street, City, State",
                "Landmark Name, City",
                "Street Name, City, Country",
                "Postal Code, Country"
            }
        };
    }

    /// <summary>
    /// Calculate string similarity using simple character-based comparison
    /// </summary>
    private static double CalculateStringSimilarity(string str1, string str2)
    {
        if (string.IsNullOrEmpty(str1) || string.IsNullOrEmpty(str2)) return 0;
        
        var longer = str1.Length > str2.Length ? str1 : str2;
        var shorter = str1.Length > str2.Length ? str2 : str1;
        
        if (longer.Length == 0) return 1.0;
        
        var editDistance = CalculateLevenshteinDistance(longer, shorter);
        return (longer.Length - editDistance) / (double)longer.Length;
    }

    /// <summary>
    /// Calculate Levenshtein distance between two strings
    /// </summary>
    private static int CalculateLevenshteinDistance(string s1, string s2)
    {
        var matrix = new int[s1.Length + 1, s2.Length + 1];

        for (int i = 0; i <= s1.Length; i++) matrix[i, 0] = i;
        for (int j = 0; j <= s2.Length; j++) matrix[0, j] = j;

        for (int i = 1; i <= s1.Length; i++)
        {
            for (int j = 1; j <= s2.Length; j++)
            {
                var cost = s1[i - 1] == s2[j - 1] ? 0 : 1;
                matrix[i, j] = Math.Min(Math.Min(matrix[i - 1, j] + 1, matrix[i, j - 1] + 1), matrix[i - 1, j - 1] + cost);
            }
        }

        return matrix[s1.Length, s2.Length];
    }

    /// <summary>
    /// <summary>
    /// Build comprehensive geocoding response
    /// </summary>
    private static object BuildGeocodingResponse(string originalQuery, List<object> results, int maxResults)
    {
        return new
        {
            Query = new
            {
                OriginalAddress = originalQuery,
                MaxResults = maxResults,
                ProcessedAt = DateTime.UtcNow
            },
            Summary = new
            {
                TotalResults = results.Count,
                HasMultipleResults = results.Count > 1,
                ResultsLimited = results.Count == maxResults,
                BestResultQuality = results.Count > 0 
                    ? results.Cast<dynamic>().Max(r => (int)r.QualityMetrics.QualityScore)
                    : 0
            },
            Results = results,
            SearchInsights = new
            {
                QueryType = DetermineQueryType(originalQuery),
                RecommendedResultIndex = 1, // Typically the first result is best
                QualityAssessment = results.Count > 0 
                    ? AssessOverallQuality(results.Cast<dynamic>().First().QualityMetrics.QualityScore)
                    : "No Results"
            }
        };
    }

    /// <summary>
    /// Determine the type of geocoding query
    /// </summary>
    private static string DetermineQueryType(string query)
    {
        var lowerQuery = query.ToLowerInvariant();
        
        if (System.Text.RegularExpressions.Regex.IsMatch(query, @"^\d+\s+[\w\s]+"))
            return "Street Address";
        
        if (lowerQuery.Contains("street") || lowerQuery.Contains("avenue") || lowerQuery.Contains("road") || 
            lowerQuery.Contains("boulevard") || lowerQuery.Contains("drive"))
            return "Street-based";
        
        if (System.Text.RegularExpressions.Regex.IsMatch(query, @"\d{5}"))
            return "Postal Code Included";
        
        if (lowerQuery.Contains("tower") || lowerQuery.Contains("building") || lowerQuery.Contains("center") ||
            lowerQuery.Contains("mall") || lowerQuery.Contains("park"))
            return "Landmark/POI";
        
        return "General Location";
    }

    /// <summary>
    /// Assess overall quality of the geocoding result
    /// </summary>
    private static string AssessOverallQuality(int qualityScore)
    {
        return qualityScore switch
        {
            >= 90 => "Excellent",
            >= 80 => "Very Good",
            >= 70 => "Good",
            >= 60 => "Fair",
            >= 50 => "Moderate",
            _ => "Low"
        };
    }

    /// <summary>
    /// Generate helpful hints for geocoding searches
    /// </summary>
    private static object GenerateGeocodingHints(string address)
    {
        var hints = new List<string>();
        
        if (address.Length < 5)
        {
            hints.Add("Try providing a more complete address");
        }
        
        if (!address.Any(char.IsDigit))
        {
            hints.Add("Include street numbers or postal codes for better accuracy");
        }
        
        if (!address.Contains(","))
        {
            hints.Add("Try adding city, state, or country information separated by commas");
        }
        
        hints.Add("Verify spelling of street names and city names");
        hints.Add("Try searching for nearby landmarks or points of interest");
        
        return new
        {
            NoResultsFound = true,
            Suggestions = hints,
            ExampleFormats = new[]
            {
                "123 Main Street, City, State",
                "Landmark Name, City",
                "Street Name, City, Country",
                "Postal Code, Country"
            }
        };
    }

    /// <summary>
    /// Converts geographic coordinates to a street address
    /// </summary>
    [Function(nameof(ReverseGeocoding))]
    public async Task<string> ReverseGeocoding(
        [McpToolTrigger(
            "search_geocoding_reverse",
            "Convert precise geographic coordinates (latitude and longitude) into human-readable street addresses and location details. This reverse geocoding service is essential for location-based applications that need to display meaningful address information from GPS coordinates or map click events. Returns formatted addresses with detailed components including street names, postal codes, and administrative boundaries."
        )] ToolInvocationContext context,
        [McpToolProperty(
            "latitude",
            "string",
            "Latitude coordinate as a decimal number (e.g., '47.6062'). Must be between -90 and 90 degrees."
        )] double latitude,
        [McpToolProperty(
            "longitude",
            "string",
            "Longitude coordinate as a decimal number (e.g., '-122.3321'). Must be between -180 and 180 degrees."
        )] double longitude
    )
    {
        try
        {
            if (latitude < -90 || latitude > 90)
            {
                return JsonSerializer.Serialize(new { error = "Latitude must be between -90 and 90 degrees" });
            }

            if (longitude < -180 || longitude > 180)
            {
                return JsonSerializer.Serialize(new { error = "Longitude must be between -180 and 180 degrees" });
            }

            logger.LogInformation("Reverse geocoding coordinates: {Latitude}, {Longitude}", latitude, longitude);

            var coordinates = new GeoPosition(longitude, latitude);
            var response = await _searchClient.GetReverseGeocodingAsync(coordinates);

            if (response.Value?.Features != null && response.Value.Features.Any())
            {
                var feature = response.Value.Features.First();
                
                // Try to get enhanced country information if country region is available
                Country? countryInfo = null;
                var countryRegion = feature.Properties.Address?.CountryRegion?.ToString();
                if (!string.IsNullOrEmpty(countryRegion))
                {
                    // Try to match by 2-letter ISO code first (most common format)
                    if (countryRegion.Length == 2)
                    {
                        countryInfo = _countryHelper.GetCountryByCode(countryRegion);
                    }
                }
                
                var result = new
                {
                    Address = feature.Properties.Address?.FormattedAddress,
                    AddressDetails = new
                    {
                        StreetNumber = feature.Properties.Address?.StreetNumber,
                        StreetName = feature.Properties.Address?.StreetName,
                        Neighborhood = feature.Properties.Address?.Neighborhood,
                        PostalCode = feature.Properties.Address?.PostalCode,
                        CountryRegion = feature.Properties.Address?.CountryRegion,
                        Locality = feature.Properties.Address?.Locality
                    },
                    CountryInfo = countryInfo, // Enhanced country data from CountryData.Standard
                    Coordinates = new
                    {
                        Latitude = latitude,
                        Longitude = longitude
                    },
                    MatchCodes = feature.Properties.MatchCodes?.Select(mc => mc.ToString()).ToArray()
                };

                logger.LogInformation("Successfully reverse geocoded coordinates");
                return JsonSerializer.Serialize(new { success = true, result }, new JsonSerializerOptions { WriteIndented = false });
            }

            logger.LogWarning("No address found for coordinates: {Latitude}, {Longitude}", latitude, longitude);
            return JsonSerializer.Serialize(new { success = false, message = "No address found for these coordinates" });
        }
        catch (RequestFailedException ex)
        {
            logger.LogError(ex, "Azure Maps API error during reverse geocoding: {Message}", ex.Message);
            return JsonSerializer.Serialize(new { error = $"API Error: {ex.Message}" });
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "Unexpected error during reverse geocoding");
            return JsonSerializer.Serialize(new { error = "An unexpected error occurred" });
        }
    }
    
    /// <summary>
    /// Gets administrative boundary polygon for a specific location
    /// </summary>
    [Function(nameof(GetPolygon))]
    public async Task<string> GetPolygon(
        [McpToolTrigger(
            "search_polygon",
            "Retrieve administrative boundary polygons for geographic locations such as city limits, postal code areas, state/province boundaries, or country borders. This service returns precise polygon coordinates that define these administrative boundaries, enabling spatial analysis, territory mapping, and geofencing applications. Essential for analyzing geographic containment, service area definition, and administrative boundary visualization."
        )] ToolInvocationContext context,
        [McpToolProperty(
            "latitude",
            "string",
            "Latitude coordinate of the location to get boundary polygon for as a decimal number (e.g., '47.61256'). Must be between -90 and 90 degrees."
        )] double latitude,
        [McpToolProperty(
            "longitude",
            "string",
            "Longitude coordinate of the location to get boundary polygon for as a decimal number (e.g., '-122.204141'). Must be between -180 and 180 degrees."
        )] double longitude,
        [McpToolProperty(
            "resultType",
            "string",
            "Type of administrative boundary to retrieve: 'locality' (city/town boundaries), 'postalCode' (postal/ZIP code boundaries), 'adminDistrict' (state/province boundaries), 'countryRegion' (country boundaries). Examples: 'locality', 'postalCode', 'adminDistrict'. Default is 'locality'."
        )] string resultType = "locality",
        [McpToolProperty(
            "resolution",
            "string",
            "Level of detail for polygon coordinates: 'small' (fewer coordinate points, faster), 'medium' (balanced detail), 'large' (highly detailed boundaries, more points). Examples: 'small', 'medium', 'large'. Default is 'small'."
        )] string resolution = "small"
    )
    {
        try
        {
            if (latitude < -90 || latitude > 90)
            {
                return JsonSerializer.Serialize(new { error = "Latitude must be between -90 and 90 degrees" });
            }

            if (longitude < -180 || longitude > 180)
            {
                return JsonSerializer.Serialize(new { error = "Longitude must be between -180 and 180 degrees" });
            }

            // Validate result type options
            var validResultTypes = new Dictionary<string, BoundaryResultTypeEnum>(StringComparer.OrdinalIgnoreCase)
            {
                { "locality", BoundaryResultTypeEnum.Locality },
                { "postalcode", BoundaryResultTypeEnum.PostalCode },
                { "admindistrict", BoundaryResultTypeEnum.AdminDistrict },
                { "countryregion", BoundaryResultTypeEnum.CountryRegion }
            };

            if (!validResultTypes.TryGetValue(resultType, out var resultTypeEnum))
            {
                var validOptions = string.Join(", ", validResultTypes.Keys);
                return JsonSerializer.Serialize(new { error = $"Invalid result type '{resultType}'. Valid options: {validOptions}" });
            }

            // Validate resolution options
            var validResolutions = new Dictionary<string, ResolutionEnum>(StringComparer.OrdinalIgnoreCase)
            {
                { "small", ResolutionEnum.Small },
                { "medium", ResolutionEnum.Medium },
                { "large", ResolutionEnum.Large }
            };

            if (!validResolutions.TryGetValue(resolution, out var resolutionEnum))
            {
                var validOptions = string.Join(", ", validResolutions.Keys);
                return JsonSerializer.Serialize(new { error = $"Invalid resolution '{resolution}'. Valid options: {validOptions}" });
            }

            logger.LogInformation("Getting polygon boundary for coordinates: {Latitude}, {Longitude} with type: {ResultType}", latitude, longitude, resultType);

            var options = new GetPolygonOptions()
            {
                Coordinates = new GeoPosition(longitude, latitude),
                ResultType = resultTypeEnum,
                Resolution = resolutionEnum
            };

            var response = await _searchClient.GetPolygonAsync(options);

            if (response.Value?.Geometry != null && response.Value.Geometry.Count > 0)
            {
                var polygons = new List<object>();

                for (int i = 0; i < response.Value.Geometry.Count; i++)
                {
                    if (response.Value.Geometry[i] is GeoPolygon polygon)
                    {
                        var coordinates = polygon.Coordinates[0].Select(coord => new
                        {
                            Latitude = coord.Latitude,
                            Longitude = coord.Longitude
                        }).ToArray();

                        polygons.Add(new
                        {
                            PolygonIndex = i,
                            CoordinateCount = coordinates.Length,
                            Coordinates = coordinates
                        });
                    }
                }

                var result = new
                {
                    BoundaryInfo = new
                    {
                        CopyrightUrl = response.Value.Properties?.CopyrightUrl,
                        Copyright = response.Value.Properties?.Copyright,
                        ResultType = resultType,
                        Resolution = resolution,
                        QueryCoordinates = new
                        {
                            Latitude = latitude,
                            Longitude = longitude
                        }
                    },
                    PolygonCount = response.Value.Geometry.Count,
                    Polygons = polygons
                };

                logger.LogInformation("Successfully retrieved {Count} polygon(s) for boundary", response.Value.Geometry.Count);
                return JsonSerializer.Serialize(new { success = true, result }, new JsonSerializerOptions { WriteIndented = false });
            }

            logger.LogWarning("No boundary polygon found for coordinates: {Latitude}, {Longitude}", latitude, longitude);
            return JsonSerializer.Serialize(new { success = false, message = "No boundary polygon found for these coordinates" });
        }
        catch (RequestFailedException ex)
        {
            logger.LogError(ex, "Azure Maps API error during polygon retrieval: {Message}", ex.Message);
            return JsonSerializer.Serialize(new { error = $"API Error: {ex.Message}" });
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "Unexpected error during polygon retrieval");
            return JsonSerializer.Serialize(new { error = "An unexpected error occurred" });
        }
    }

    /// <summary>
    /// Get comprehensive country information by ISO country code with enhanced data and insights
    /// </summary>
    [Function(nameof(GetCountryInfo))]
    public Task<string> GetCountryInfo(
        [McpToolTrigger(
            "search_country_info",
            "Get comprehensive country information including demographics, geography, economics, and cultural data by ISO country code. Returns enhanced country details with validation insights, related country suggestions, and data quality metrics. Provides rich context for location-based applications, international business, travel planning, and geographic analysis. Includes intelligent error handling and helpful suggestions for invalid codes."
        )] ToolInvocationContext context,
        [McpToolProperty(
            "countryCode",
            "string",
            "ISO 3166-1 alpha-2 country code (2 letters) or alpha-3 code (3 letters). Automatically normalizes input and provides suggestions for invalid codes. Case-insensitive processing. Examples: 'US'/'USA', 'CA'/'CAN', 'GB'/'GBR', 'DE'/'DEU', 'JP'/'JPN', 'AU'/'AUS', 'FR'/'FRA'. Also accepts common variations and provides correction suggestions."
        )] string countryCode
    )
    {
        var startTime = DateTime.UtcNow;

        try
        {
            // Enhanced input validation with intelligent normalization
            var validationResult = ValidateAndNormalizeCountryCode(countryCode);
            if (!validationResult.IsValid)
            {
                return Task.FromResult(JsonSerializer.Serialize(new { 
                    error = validationResult.ErrorMessage,
                    inputReceived = countryCode,
                    suggestions = validationResult.Suggestions,
                    timestamp = startTime
                }));
            }

            var normalizedCode = validationResult.NormalizedCode!;
            logger.LogInformation("Getting enhanced country information for code: {CountryCode}", normalizedCode);

            // Attempt to get country data with fallback strategies
            var countryResult = GetCountryWithFallback(normalizedCode);
            var endTime = DateTime.UtcNow;

            if (countryResult.Country != null)
            {
                // Build comprehensive response with enhanced country data
                var response = BuildEnhancedCountryResponse(countryResult.Country, normalizedCode, 
                    countryResult.MatchMethod, startTime, endTime);

                logger.LogInformation("Successfully retrieved enhanced country information for: {CountryName} using {Method} in {Duration}ms", 
                    countryResult.Country.CountryName, countryResult.MatchMethod, (endTime - startTime).TotalMilliseconds);

                return Task.FromResult(JsonSerializer.Serialize(new { 
                    success = true, 
                    country = countryResult.Country, // Maintain backward compatibility 
                    data = response // Enhanced response structure
                }, new JsonSerializerOptions { WriteIndented = false }));
            }

            // Enhanced error response with helpful suggestions
            var errorResponse = BuildCountryNotFoundResponse(normalizedCode, countryCode, startTime, endTime);
            logger.LogWarning("No country data found for code: {CountryCode}", normalizedCode);

            return Task.FromResult(JsonSerializer.Serialize(errorResponse));
        }
        catch (Exception ex)
        {
            var endTime = DateTime.UtcNow;
            logger.LogError(ex, "Unexpected error during country lookup for code: {CountryCode}", countryCode);
            return Task.FromResult(JsonSerializer.Serialize(new { 
                error = "An unexpected error occurred during country lookup",
                details = ex.Message,
                inputReceived = countryCode,
                processingTime = (endTime - startTime).TotalMilliseconds,
                timestamp = startTime
            }));
        }
    }

    /// <summary>
    /// Validates and normalizes country code input with intelligent suggestions
    /// </summary>
    private static (bool IsValid, string? ErrorMessage, string? NormalizedCode, List<string>? Suggestions) ValidateAndNormalizeCountryCode(string? countryCode)
    {
        if (string.IsNullOrWhiteSpace(countryCode))
        {
            return (false, "Country code is required and cannot be empty", null, new List<string>
            {
                "Provide a 2-letter ISO code like 'US', 'GB', 'DE'",
                "Use 3-letter codes like 'USA', 'GBR', 'DEU'",
                "Ensure the code is not empty or whitespace"
            });
        }

        var trimmedCode = countryCode.Trim().ToUpperInvariant();

        // Validate length and format
        if (trimmedCode.Length < 2 || trimmedCode.Length > 3)
        {
            return (false, $"Country code '{countryCode}' must be 2 or 3 letters long", null, new List<string>
            {
                "Use 2-letter ISO 3166-1 alpha-2 codes (e.g., 'US', 'CA', 'GB')",
                "Use 3-letter ISO 3166-1 alpha-3 codes (e.g., 'USA', 'CAN', 'GBR')",
                "Check for typos in the country code"
            });
        }

        // Validate that it contains only letters
        if (!trimmedCode.All(char.IsLetter))
        {
            return (false, $"Country code '{countryCode}' must contain only letters", null, new List<string>
            {
                "Remove any numbers, spaces, or special characters",
                "Use only alphabetic characters (A-Z)",
                "Examples of valid codes: 'US', 'DE', 'JP', 'USA', 'DEU', 'JPN'"
            });
        }

        // Handle 3-letter to 2-letter conversion for common cases
        if (trimmedCode.Length == 3)
        {
            var converted = ConvertThreeLetterToTwoLetter(trimmedCode);
            if (converted != null)
            {
                return (true, null, converted, null);
            }
        }

        return (true, null, trimmedCode, null);
    }

    /// <summary>
    /// Convert common 3-letter country codes to 2-letter equivalents
    /// </summary>
    private static string? ConvertThreeLetterToTwoLetter(string threeLetterCode)
    {
        var conversionMap = new Dictionary<string, string>
        {
            ["USA"] = "US", ["CAN"] = "CA", ["GBR"] = "GB", ["DEU"] = "DE", ["FRA"] = "FR",
            ["JPN"] = "JP", ["AUS"] = "AU", ["CHN"] = "CN", ["IND"] = "IN", ["BRA"] = "BR",
            ["RUS"] = "RU", ["ITA"] = "IT", ["ESP"] = "ES", ["MEX"] = "MX", ["KOR"] = "KR",
            ["NLD"] = "NL", ["BEL"] = "BE", ["CHE"] = "CH", ["AUT"] = "AT", ["SWE"] = "SE",
            ["NOR"] = "NO", ["DNK"] = "DK", ["FIN"] = "FI", ["POL"] = "PL", ["TUR"] = "TR"
        };

        return conversionMap.TryGetValue(threeLetterCode, out var twoLetterCode) ? twoLetterCode : null;
    }

    /// <summary>
    /// Attempts to get country data with multiple fallback strategies
    /// </summary>
    private (Country? Country, string MatchMethod) GetCountryWithFallback(string countryCode)
    {
        // Primary attempt: Direct code lookup
        var country = _countryHelper.GetCountryByCode(countryCode);
        if (country != null)
        {
            return (country, "Direct Code Match");
        }

        // Fallback 1: Try alternative code formats
        if (countryCode.Length == 2)
        {
            // Try common variations for 2-letter codes
            var variations = GenerateCodeVariations(countryCode);
            foreach (var variation in variations)
            {
                country = _countryHelper.GetCountryByCode(variation);
                if (country != null)
                {
                    return (country, $"Alternative Format ({variation})");
                }
            }
        }

        // Fallback 2: Fuzzy search through all countries
        var allCountries = _countryHelper.GetCountryData();
        foreach (var c in allCountries)
        {
            if (c.CountryShortCode.Equals(countryCode, StringComparison.OrdinalIgnoreCase))
            {
                return (c, "Case-Insensitive Match");
            }
        }

        return (null, "No Match Found");
    }

    /// <summary>
    /// Generate alternative code variations for better matching
    /// </summary>
    private static List<string> GenerateCodeVariations(string code)
    {
        var variations = new List<string>();
        
        // Try lowercase
        variations.Add(code.ToLowerInvariant());
        
        // Try with different casing
        if (code.Length == 2)
        {
            variations.Add(char.ToUpper(code[0]) + code[1..].ToLower());
        }

        return variations;
    }

    /// <summary>
    /// Builds comprehensive country response with enhanced data and insights
    /// </summary>
    private object BuildEnhancedCountryResponse(Country country, string requestedCode, string matchMethod, DateTime startTime, DateTime endTime)
    {
        return new
        {
            CountryInfo = new
            {
                Country = country,
                RequestedCode = requestedCode,
                ActualCode = country.CountryShortCode,
                MatchMethod = matchMethod,
                DataSource = "CountryData.Standard Library"
            },
            Enhancement = new
            {
                ProcessingTime = new
                {
                    ProcessingTimeMs = (int)(endTime - startTime).TotalMilliseconds,
                    StartTime = startTime,
                    EndTime = endTime
                },
                DataQuality = new
                {
                    Confidence = "High",
                    DataCompleteness = CalculateCountryDataCompleteness(country),
                    LastValidated = "Library Maintained",
                    ReliabilityScore = CalculateReliabilityScore(matchMethod)
                }
            },
            RelatedData = new
            {
                RegionalContext = GetRegionalContext(country),
                SimilarCountries = FindSimilarCountries(country),
                UsageGuidance = GenerateCountryUsageGuidance(country, matchMethod)
            },
            TechnicalInfo = new
            {
                CodeValidation = new
                {
                    InputCode = requestedCode,
                    NormalizedCode = country.CountryShortCode,
                    IsExactMatch = requestedCode.Equals(country.CountryShortCode, StringComparison.OrdinalIgnoreCase),
                    AlternativeCodes = GetAlternativeCountryCodes(country)
                }
            }
        };
    }

    /// <summary>
    /// Calculate data completeness percentage for country information
    /// </summary>
    private static int CalculateCountryDataCompleteness(Country country)
    {
        var fields = new object?[]
        {
            country.CountryName,
            country.CountryShortCode,
            // Add other available properties as needed
        };

        var populatedFields = fields.Count(f => f != null && !string.IsNullOrWhiteSpace(f.ToString()));
        return (populatedFields * 100) / fields.Length;
    }

    /// <summary>
    /// Calculate reliability score based on match method
    /// </summary>
    private static int CalculateReliabilityScore(string matchMethod)
    {
        return matchMethod switch
        {
            "Direct Code Match" => 100,
            "Case-Insensitive Match" => 95,
            var method when method.StartsWith("Alternative Format") => 90,
            _ => 80
        };
    }

    /// <summary>
    /// Get regional context for the country
    /// </summary>
    private object GetRegionalContext(Country country)
    {
        // This is a simplified example - could be enhanced with actual regional data
        return new
        {
            Note = "Regional context would be available with enhanced geographic data",
            CountryCode = country.CountryShortCode,
            CountryName = country.CountryName
        };
    }

    /// <summary>
    /// Find countries with similar characteristics
    /// </summary>
    private List<object> FindSimilarCountries(Country targetCountry)
    {
        try
        {
            var allCountries = _countryHelper.GetCountryData();
            
            // Find countries with similar names or characteristics
            var similarCountries = allCountries
                .Where(c => c.CountryShortCode != targetCountry.CountryShortCode)
                .Where(c => c.CountryName.Contains(' ') == targetCountry.CountryName.Contains(' ') ||
                           Math.Abs(c.CountryName.Length - targetCountry.CountryName.Length) <= 3)
                .Take(3)
                .Select(c => new
                {
                    CountryCode = c.CountryShortCode,
                    CountryName = c.CountryName,
                    SimilarityReason = "Name characteristics"
                })
                .ToList<object>();

            return similarCountries;
        }
        catch
        {
            return new List<object>();
        }
    }

    /// <summary>
    /// Generate usage guidance based on country and match method
    /// </summary>
    private static List<string> GenerateCountryUsageGuidance(Country country, string matchMethod)
    {
        var guidance = new List<string>();

        if (matchMethod == "Direct Code Match")
        {
            guidance.Add("Perfect match found - use this data with high confidence");
        }
        else
        {
            guidance.Add($"Country found using {matchMethod} - verify if this matches your intended country");
        }

        guidance.Add("Use the CountryShortCode for standardized references");
        guidance.Add("Cache this country data for improved performance in repeated lookups");
        
        if (country.CountryName.Contains("United"))
        {
            guidance.Add("Note: This country name contains 'United' - ensure correct country selection");
        }

        return guidance;
    }

    /// <summary>
    /// Get alternative country codes and formats
    /// </summary>
    private static object GetAlternativeCountryCodes(Country country)
    {
        return new
        {
            ISO_Alpha2 = country.CountryShortCode,
            CommonVariations = new[]
            {
                country.CountryShortCode.ToLowerInvariant(),
                country.CountryShortCode.ToUpperInvariant()
            },
            Note = "Additional ISO-3166 codes would be available with enhanced country data provider"
        };
    }

    /// <summary>
    /// Build comprehensive error response for country not found
    /// </summary>
    private object BuildCountryNotFoundResponse(string normalizedCode, string originalInput, DateTime startTime, DateTime endTime)
    {
        var suggestions = GenerateCountryCodeSuggestions(normalizedCode);
        
        return new
        {
            success = false,
            message = $"No country data found for code '{normalizedCode}'",
            searchDetails = new
            {
                InputReceived = originalInput,
                NormalizedCode = normalizedCode,
                ProcessingTime = (endTime - startTime).TotalMilliseconds,
                SearchMethod = "Comprehensive lookup with fallbacks"
            },
            suggestions = suggestions,
            troubleshooting = new
            {
                CommonIssues = new[]
                {
                    "Verify the country code spelling",
                    "Ensure using standard ISO 3166-1 codes",
                    "Check if using obsolete or non-standard codes"
                },
                ExampleValidCodes = new[]
                {
                    "US (United States)", "CA (Canada)", "GB (United Kingdom)",
                    "DE (Germany)", "FR (France)", "JP (Japan)", "AU (Australia)"
                }
            },
            timestamp = startTime
        };
    }

    /// <summary>
    /// Generate intelligent suggestions for invalid country codes
    /// </summary>
    private List<object> GenerateCountryCodeSuggestions(string invalidCode)
    {
        var suggestions = new List<object>();

        try
        {
            var allCountries = _countryHelper.GetCountryData();
            
            // Find countries with similar codes
            var similarCodes = allCountries
                .Where(c => CalculateStringSimilarity(c.CountryShortCode, invalidCode) > 0.5)
                .Take(5)
                .Select(c => new
                {
                    CountryCode = c.CountryShortCode,
                    CountryName = c.CountryName,
                    Similarity = Math.Round(CalculateStringSimilarity(c.CountryShortCode, invalidCode) * 100, 1)
                })
                .Cast<object>()
                .ToList();

            if (similarCodes.Any())
            {
                suggestions.AddRange(similarCodes);
            }
            else
            {
                // Provide common country codes as fallback
                suggestions.AddRange(new object[]
                {
                    new { CountryCode = "US", CountryName = "United States", Note = "Most common code" },
                    new { CountryCode = "GB", CountryName = "United Kingdom", Note = "Common European code" },
                    new { CountryCode = "DE", CountryName = "Germany", Note = "Common European code" }
                });
            }
        }
        catch
        {
            // Fallback suggestions if country data access fails
            suggestions.Add(new { Note = "Unable to generate specific suggestions - verify country code format" });
        }

        return suggestions;
    }

    /// <summary>
    /// Find countries by various criteria like name, continent, or region
    /// </summary>
    [Function(nameof(FindCountries))]
    public Task<string> FindCountries(
        [McpToolTrigger(
            "search_countries",
            "Find countries by name, continent, or other criteria with intelligent matching and scoring. This tool helps discover countries that match specific geographic, cultural, or economic characteristics. Supports partial name matching, exact code matching, and flexible search patterns. Useful for regional analysis, travel planning, and geographic data exploration."
        )] ToolInvocationContext context,
        [McpToolProperty(
            "searchTerm",
            "string",
            "Search term to find countries. Can be partial country name, exact country code, or geographic identifier. Examples: 'Unit' (finds United States/Kingdom), 'US' (exact match), 'Europe', 'Asia', 'America', 'Island'"
        )] string searchTerm,
        [McpToolProperty(
            "maxResults",
            "string",
            "Maximum number of countries to return as a string number. Must be between 1 and 50. Examples: '5', '10', '20'. Default is '10' if not specified."
        )] int maxResults = 10
    )
    {
        try
        {
            // Validate input
            var validationError = ValidateSearchInput(searchTerm, ref maxResults);
            if (validationError != null)
            {
                return Task.FromResult(JsonSerializer.Serialize(new { error = validationError }));
            }

            logger.LogInformation("Searching for countries with term: '{SearchTerm}'", searchTerm);

            var allCountries = _countryHelper.GetCountryData();
            var searchResults = SearchCountriesWithScoring(allCountries, searchTerm, maxResults);

            var result = BuildSearchResult(searchTerm, searchResults, maxResults, allCountries.Count());

            logger.LogInformation("Found {Count} countries matching '{SearchTerm}'", searchResults.Count, searchTerm);
            return Task.FromResult(JsonSerializer.Serialize(new { success = true, result }, new JsonSerializerOptions { WriteIndented = false }));
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "Unexpected error during country search");
            return Task.FromResult(JsonSerializer.Serialize(new { error = "An unexpected error occurred" }));
        }
    }

    /// <summary>
    /// Validate search input parameters
    /// </summary>
    private static string? ValidateSearchInput(string? searchTerm, ref int maxResults)
    {
        if (string.IsNullOrWhiteSpace(searchTerm))
        {
            return "Search term is required";
        }

        if (searchTerm.Trim().Length < 2)
        {
            return "Search term must be at least 2 characters long";
        }

        maxResults = Math.Max(1, Math.Min(50, maxResults));
        return null;
    }

    /// <summary>
    /// Search countries with intelligent scoring and ranking
    /// </summary>
    private static List<(Country Country, int Score, string MatchType)> SearchCountriesWithScoring(
        IEnumerable<Country> countries, string searchTerm, int maxResults)
    {
        var normalizedSearchTerm = searchTerm.Trim();
        
        var scoredResults = countries
            .Select(country => 
            {
                var (score, matchType) = CalculateCountryMatchScore(country, normalizedSearchTerm);
                return (Country: country, Score: score, MatchType: matchType);
            })
            .Where(result => result.Score > 0)
            .OrderByDescending(result => result.Score)
            .ThenBy(result => result.Country.CountryName)
            .Take(maxResults)
            .ToList();

        return scoredResults;
    }

    /// <summary>
    /// Calculate match score for a country based on search criteria
    /// </summary>
    private static (int Score, string MatchType) CalculateCountryMatchScore(Country country, string searchTerm)
    {
        const int ExactCodeMatch = 100;
        const int ExactNameMatch = 90;
        const int StartsWithMatch = 80;
        const int ContainsMatch = 60;
        const int PartialMatch = 40;

        var comparison = StringComparison.OrdinalIgnoreCase;

        // Exact country code match (highest priority)
        if (country.CountryShortCode.Equals(searchTerm, comparison))
        {
            return (ExactCodeMatch, "Exact Code Match");
        }

        // Exact country name match
        if (country.CountryName.Equals(searchTerm, comparison))
        {
            return (ExactNameMatch, "Exact Name Match");
        }

        // Country name starts with search term
        if (country.CountryName.StartsWith(searchTerm, comparison))
        {
            return (StartsWithMatch, "Name Prefix Match");
        }

        // Country name contains search term
        if (country.CountryName.Contains(searchTerm, comparison))
        {
            return (ContainsMatch, "Name Contains Match");
        }

        // Check for partial word matches in country name
        var countryWords = country.CountryName.Split(' ', StringSplitOptions.RemoveEmptyEntries);
        foreach (var word in countryWords)
        {
            if (word.StartsWith(searchTerm, comparison) && searchTerm.Length >= 3)
            {
                return (PartialMatch, "Word Prefix Match");
            }
        }

        return (0, "No Match");
    }

    /// <summary>
    /// Build the final search result response
    /// </summary>
    private static object BuildSearchResult(string searchTerm, 
        List<(Country Country, int Score, string MatchType)> searchResults, 
        int maxResults, int totalCountriesAvailable)
    {
        var countries = searchResults.Select(result => new
        {
            Country = result.Country,
            MatchScore = result.Score,
            MatchType = result.MatchType,
            MatchDetails = new
            {
                CountryCode = result.Country.CountryShortCode,
                CountryName = result.Country.CountryName
            }
        }).ToList();

        return new
        {
            SearchCriteria = new
            {
                SearchTerm = searchTerm,
                MaxResults = maxResults,
                TotalCountriesSearched = totalCountriesAvailable
            },
            Results = new
            {
                TotalMatches = searchResults.Count,
                HasMoreResults = searchResults.Count == maxResults,
                Countries = countries
            },
            SearchStats = searchResults.Any() ? new
            {
                BestMatchScore = searchResults.Max(r => r.Score),
                MatchTypes = searchResults.GroupBy(r => r.MatchType)
                    .Select(g => new { Type = g.Key, Count = g.Count() })
                    .ToList()
            } : null,
            SearchHints = GenerateSearchHints(searchTerm, searchResults.Count)
        };
    }

    /// <summary>
    /// Generate helpful search hints based on results
    /// </summary>
    private static object? GenerateSearchHints(string searchTerm, int resultCount)
    {
        if (resultCount == 0)
        {
            return new
            {
                NoResults = true,
                Suggestions = new[]
                {
                    "Try a shorter search term (2-3 letters)",
                    "Use partial country names like 'Unit' for United States/Kingdom",
                    "Use standard country codes like 'US', 'GB', 'DE'",
                    "Check spelling of the country name"
                }
            };
        }

        if (resultCount == 1)
        {
            return new
            {
                SingleResult = true,
                Note = "Perfect match found! This might be exactly what you're looking for."
            };
        }

        if (searchTerm.Length == 2)
        {
            return new
            {
                CountryCodeSearch = true,
                Note = "2-letter search detected. This might be a country code search."
            };
        }

        return null;
    }
}